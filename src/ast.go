// Code generated by goyacc -o ast.go -p ast ast.y. DO NOT EDIT.

//line ast.y:1

package main

import __yyfmt__ "fmt"

//line ast.y:3
const (
	AstBlockUnfin    = 10
	AstBlock         = 11
	AstQCircleUnfin  = 12
	AstQCircle       = 13
	AstQuoteUnfin    = 14
	AstQuote         = 15
	AstTicklitUnfin  = 16
	AstTicklit       = 17
	AstInterpolUnfin = 18
	AstInterpol      = 19
	AstToplevel      = 20
	AstMacro         = 21
	AstLfnArgs       = 22
	AstLfnRetType    = 23
	AstLfnBody       = 24
	AstEnd           = 25
)

/* this is a "union" between
   token and nodes. all of
   the actual token constants are enormous,
   so if token.kind < AstEnd, we know it is an
   []AstNode instead. */
type AstNode struct {
	token LexToken
	nodes []AstNode
}

//line ast.y:46
type astSymType struct {
	yys  int
	node AstNode
}

const TIdentifier = 57346
const TConst = 57347
const TStructUnionEnum = 57348
const TFunctionForWhileClass = 57349
const TJsOnly = 57350
const TMinusGt = 57351
const TEq = 57352
const TLSquare = 57353
const TRSquare = 57354
const TOther = 57355
const TLBrace = 57356
const TRBrace = 57357
const TQuote = 57358
const TDollarLBrace = 57359
const TTick = 57360
const TLCircle = 57361
const TRCircle = 57362
const TSemi = 57363
const TMacroStart = 57364
const TMacroEnd = 57365

var astToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"TIdentifier",
	"TConst",
	"TStructUnionEnum",
	"TFunctionForWhileClass",
	"TJsOnly",
	"TMinusGt",
	"TEq",
	"TLSquare",
	"TRSquare",
	"TOther",
	"TLBrace",
	"TRBrace",
	"TQuote",
	"TDollarLBrace",
	"TTick",
	"TLCircle",
	"TRCircle",
	"TSemi",
	"TMacroStart",
	"TMacroEnd",
}

var astStatenames = [...]string{}

const astEofCode = 1
const astErrCode = 2
const astInitialStackSize = 16

//line yacctab:1
var astExca = [...]int8{
	-1, 1,
	1, -1,
	-2, 0,
}

const astPrivate = 57344

const astLast = 192

var astAct = [...]int8{
	9, 35, 50, 34, 78, 3, 4, 11, 33, 8,
	45, 7, 27, 10, 49, 47, 68, 59, 46, 48,
	1, 2, 25, 24, 42, 23, 57, 66, 77, 43,
	37, 26, 52, 61, 70, 56, 65, 55, 64, 58,
	67, 0, 0, 0, 42, 80, 0, 79, 0, 57,
	37, 82, 0, 0, 0, 52, 0, 0, 56, 0,
	55, 0, 58, 12, 13, 14, 15, 16, 17, 18,
	19, 20, 21, 71, 72, 75, 30, 76, 73, 74,
	22, 0, 69, 12, 13, 14, 15, 16, 17, 18,
	19, 20, 21, 31, 0, 28, 30, 29, 5, 6,
	22, 32, 12, 13, 14, 15, 16, 17, 18, 19,
	20, 21, 31, 83, 28, 30, 29, 53, 54, 22,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	38, 39, 40, 30, 41, 44, 81, 22, 12, 13,
	14, 15, 16, 17, 18, 19, 20, 21, 31, 60,
	28, 30, 29, 62, 63, 22, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 31, 51, 28, 30,
	29, 53, 54, 22, 12, 13, 14, 15, 16, 17,
	18, 19, 20, 21, 38, 39, 40, 30, 41, 44,
	36, 22,
}

var astPact = [...]int16{
	79, -1000, 79, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, 170, -3, 152, 134, 59, -15, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, 116, -1000, -1000, -1000, -1000, 98, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000,
}

var astPgo = [...]int8{
	0, 6, 31, 13, 3, 29, 1, 25, 11, 23,
	9, 22, 0, 21, 20, 19, 18, 17, 2, 5,
	16, 12, 7,
}

var astR1 = [...]int8{
	0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 17, 17, 17, 17, 17, 17, 17, 2,
	2, 3, 4, 4, 4, 4, 4, 4, 5, 5,
	5, 6, 7, 7, 7, 8, 18, 18, 18, 18,
	18, 18, 18, 15, 15, 16, 9, 9, 9, 10,
	11, 11, 12, 20, 20, 20, 20, 20, 20, 20,
	20, 21, 21, 22, 19, 19, 19, 19, 19, 19,
	19, 19, 13, 13, 14,
}

var astR2 = [...]int8{
	0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	2, 2, 1, 1, 1, 1, 1, 1, 1, 2,
	2, 2, 2, 2, 2, 2, 1, 1, 1, 1,
	1, 1, 1, 1, 2, 2, 1, 2, 2, 2,
	1, 2, 2, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 2, 2, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 2, 1,
}

var astChk = [...]int16{
	-1000, -14, -13, -19, -1, 19, 20, -8, -10, -12,
	-3, -22, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 21, -7, -9, -11, -2, -21, 16, 18,
	17, 14, 22, -19, -4, -6, 20, -1, 14, 15,
	16, 18, -12, -5, 19, 13, -16, 18, -15, 17,
	-18, 15, -1, 19, 20, -8, -10, -12, -3, -17,
	15, -1, 19, 20, -8, -10, -12, -3, -20, 23,
	-1, 14, 15, 19, 20, 16, 18, -12, 19, -4,
	-6, 20, -18, 15,
}

var astDef = [...]int8{
	0, -2, 74, 72, 64, 65, 66, 67, 68, 69,
	70, 71, 1, 2, 3, 4, 5, 6, 7, 8,
	9, 10, 11, 0, 0, 0, 0, 0, 0, 46,
	50, 19, 61, 73, 33, 34, 35, 22, 23, 24,
	25, 26, 27, 0, 28, 47, 48, 49, 0, 43,
	51, 52, 36, 37, 38, 39, 40, 41, 42, 20,
	21, 12, 13, 14, 15, 16, 17, 18, 62, 63,
	53, 54, 55, 56, 57, 58, 59, 60, 32, 29,
	30, 31, 44, 45,
}

var astTok1 = [...]int8{
	1,
}

var astTok2 = [...]int8{
	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23,
}

var astTok3 = [...]int8{
	0,
}

var astErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	astDebug        = 0
	astErrorVerbose = false
)

type astLexer interface {
	Lex(lval *astSymType) int
	Error(s string)
}

type astParser interface {
	Parse(*ParserLexer) int
	Lookahead() int
}

type astParserImpl struct {
	lval  astSymType
	stack [astInitialStackSize]astSymType
	char  int
}

func (p *astParserImpl) Lookahead() int {
	return p.char
}

func astNewParser() astParser {
	return &astParserImpl{}
}

const astFlag = -1000

func astTokname(c int) string {
	if c >= 1 && c-1 < len(astToknames) {
		if astToknames[c-1] != "" {
			return astToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func astStatname(s int) string {
	if s >= 0 && s < len(astStatenames) {
		if astStatenames[s] != "" {
			return astStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func astErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !astErrorVerbose {
		return "syntax error"
	}

	for _, e := range astErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + astTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(astPact[state])
	for tok := TOKSTART; tok-1 < len(astToknames); tok++ {
		if n := base + tok; n >= 0 && n < astLast && int(astChk[int(astAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if astDef[state] == -2 {
		i := 0
		for astExca[i] != -1 || int(astExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; astExca[i] >= 0; i += 2 {
			tok := int(astExca[i])
			if tok < TOKSTART || astExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if astExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += astTokname(tok)
	}
	return res
}

func astlex1(lex *ParserLexer, lval *astSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(astTok1[0])
		goto out
	}
	if char < len(astTok1) {
		token = int(astTok1[char])
		goto out
	}
	if char >= astPrivate {
		if char < astPrivate+len(astTok2) {
			token = int(astTok2[char-astPrivate])
			goto out
		}
	}
	for i := 0; i < len(astTok3); i += 2 {
		token = int(astTok3[i+0])
		if token == char {
			token = int(astTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(astTok2[1]) /* unknown char */
	}
	if astDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", astTokname(token), uint(char))
	}
	return char, token
}

func astParse(astlex *ParserLexer) int {
	return astNewParser().Parse(astlex)
}

func (astrcvr *astParserImpl) Parse(astlex *ParserLexer) int {
	var astn int
	var astVAL astSymType
	var astDollar []astSymType
	_ = astDollar // silence set and not used
	astS := astrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	aststate := 0
	astrcvr.char = -1
	asttoken := -1 // astrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		aststate = -1
		astrcvr.char = -1
		asttoken = -1
	}()
	astp := -1
	goto aststack

ret0:
	return 0

ret1:
	return 1

aststack:
	/* put a state and value onto the stack */
	if astDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", astTokname(asttoken), astStatname(aststate))
	}

	astp++
	if astp >= len(astS) {
		nyys := make([]astSymType, len(astS)*2)
		copy(nyys, astS)
		astS = nyys
	}
	astS[astp] = astVAL
	astS[astp].yys = aststate

astnewstate:
	astn = int(astPact[aststate])
	if astn <= astFlag {
		goto astdefault /* simple state */
	}
	if astrcvr.char < 0 {
		astrcvr.char, asttoken = astlex1(astlex, &astrcvr.lval)
	}
	astn += asttoken
	if astn < 0 || astn >= astLast {
		goto astdefault
	}
	astn = int(astAct[astn])
	if int(astChk[astn]) == asttoken { /* valid shift */
		astrcvr.char = -1
		asttoken = -1
		astVAL = astrcvr.lval
		aststate = astn
		if Errflag > 0 {
			Errflag--
		}
		goto aststack
	}

astdefault:
	/* default state action */
	astn = int(astDef[aststate])
	if astn == -2 {
		if astrcvr.char < 0 {
			astrcvr.char, asttoken = astlex1(astlex, &astrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if astExca[xi+0] == -1 && int(astExca[xi+1]) == aststate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			astn = int(astExca[xi+0])
			if astn < 0 || astn == asttoken {
				break
			}
		}
		astn = int(astExca[xi+1])
		if astn < 0 {
			goto ret0
		}
	}
	if astn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			astlex.Error(astErrorMessage(aststate, asttoken))
			Nerrs++
			if astDebug >= 1 {
				__yyfmt__.Printf("%s", astStatname(aststate))
				__yyfmt__.Printf(" saw %s\n", astTokname(asttoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for astp >= 0 {
				astn = int(astPact[astS[astp].yys]) + astErrCode
				if astn >= 0 && astn < astLast {
					aststate = int(astAct[astn]) /* simulate a shift of "error" */
					if int(astChk[aststate]) == astErrCode {
						goto aststack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if astDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", astS[astp].yys)
				}
				astp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if astDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", astTokname(asttoken))
			}
			if asttoken == astEofCode {
				goto ret1
			}
			astrcvr.char = -1
			asttoken = -1
			goto astnewstate /* try again in the same state */
		}
	}

	/* reduction by production astn */
	if astDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", astn, astStatname(aststate))
	}

	astnt := astn
	astpt := astp
	_ = astpt // guard against "declared and not used"

	astp -= int(astR2[astn])
	// astp is now the index of $0. Perform the default action. Iff the
	// reduced production is Îµ, $1 is possibly out of range.
	if astp+1 >= len(astS) {
		nyys := make([]astSymType, len(astS)*2)
		copy(nyys, astS)
		astS = nyys
	}
	astVAL = astS[astp+1]

	/* consult goto table to find next state */
	astn = int(astR1[astn])
	astg := int(astPgo[astn])
	astj := astg + astS[astp].yys + 1

	if astj >= astLast {
		aststate = int(astAct[astg])
	} else {
		aststate = int(astAct[astj])
		if int(astChk[aststate]) != -astn {
			aststate = int(astAct[astg])
		}
	}
	// dummy call; replaced with literal code
	switch astnt {

	case 19:
		astDollar = astS[astpt-1 : astpt+1]
//line ast.y:99
		{
			astlex.beginBlock()
			astVAL.node = AstNode{LexToken{0, 0, AstBlockUnfin}, []AstNode{astDollar[1].node}}
		}
	case 20:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:100
		{
			astDollar[1].node.nodes = append(astDollar[1].node.nodes, astDollar[2].node)
			astVAL.node = astDollar[1].node
		}
	case 21:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:103
		{
			astlex.endBlock()
			astVAL.node = AstNode{LexToken{0, 0, AstBlock}, append(astDollar[1].node.nodes, astDollar[2].node)}
		}
	case 28:
		astDollar = astS[astpt-1 : astpt+1]
//line ast.y:115
		{
			astVAL.node = AstNode{LexToken{0, 0, AstQCircleUnfin}, []AstNode{astDollar[1].node}}
		}
	case 29:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:116
		{
			astDollar[1].node.nodes = append(astDollar[1].node.nodes, astDollar[2].node)
			astVAL.node = astDollar[1].node
		}
	case 30:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:117
		{
			astDollar[1].node.nodes = append(astDollar[1].node.nodes, astDollar[2].node.nodes...)
			astVAL.node = astDollar[1].node
		}
	case 32:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:124
		{
			astVAL.node = AstNode{LexToken{0, 0, AstQuoteUnfin}, []AstNode{astDollar[1].node, astDollar[2].node}}
		}
	case 33:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:126
		{
			astDollar[1].node.nodes = append(astDollar[1].node.nodes, astDollar[2].node)
			astVAL.node = astDollar[1].node
		}
	case 34:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:128
		{
			astDollar[1].node.nodes = append(astDollar[1].node.nodes, astDollar[2].node.nodes...)
			astVAL.node = astDollar[1].node
		}
	case 35:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:131
		{
			astVAL.node = AstNode{LexToken{0, 0, AstQuote}, append(astDollar[1].node.nodes, astDollar[2].node)}
		}
	case 43:
		astDollar = astS[astpt-1 : astpt+1]
//line ast.y:145
		{
			astlex.beginBlock()
			astlex.outTicks()
			astVAL.node = AstNode{LexToken{0, 0, AstInterpolUnfin}, []AstNode{astDollar[1].node}}
		}
	case 44:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:146
		{
			astDollar[1].node.nodes = append(astDollar[1].node.nodes, astDollar[2].node)
			astVAL.node = astDollar[1].node
		}
	case 45:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:149
		{
			astlex.endBlock()
			astlex.inTicks()
			astVAL.node = AstNode{LexToken{0, 0, AstInterpol}, append(astDollar[1].node.nodes, astDollar[2].node)}
		}
	case 46:
		astDollar = astS[astpt-1 : astpt+1]
//line ast.y:152
		{
			astlex.inTicks()
			astVAL.node = AstNode{LexToken{0, 0, AstTicklitUnfin}, []AstNode{astDollar[1].node}}
		}
	case 47:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:153
		{
			astDollar[1].node.nodes = append(astDollar[1].node.nodes, astDollar[2].node)
			astVAL.node = astDollar[1].node
		}
	case 48:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:154
		{
			astDollar[1].node.nodes = append(astDollar[1].node.nodes, astDollar[2].node)
			astVAL.node = astDollar[1].node
		}
	case 49:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:158
		{
			astlex.outTicks()
			astVAL.node = AstNode{LexToken{0, 0, AstTicklit}, append(astDollar[1].node.nodes, astDollar[2].node)}
		}
	case 50:
		astDollar = astS[astpt-1 : astpt+1]
//line ast.y:162
		{
			astlex.beginBlock()
			astVAL.node = AstNode{LexToken{0, 0, AstInterpolUnfin}, []AstNode{astDollar[1].node}}
		}
	case 51:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:163
		{
			astDollar[1].node.nodes = append(astDollar[1].node.nodes, astDollar[2].node)
			astVAL.node = astDollar[1].node
		}
	case 52:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:166
		{
			astlex.endBlock()
			astVAL.node = AstNode{LexToken{0, 0, AstInterpol}, append(astDollar[1].node.nodes, astDollar[2].node)}
		}
	case 61:
		astDollar = astS[astpt-1 : astpt+1]
//line ast.y:180
		{
			astVAL.node = AstNode{LexToken{0, 0, AstMacro}, []AstNode{astDollar[1].node}}
		}
	case 62:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:181
		{
			astDollar[1].node.nodes = append(astDollar[1].node.nodes, astDollar[2].node)
			astVAL.node = astDollar[1].node
		}
	case 72:
		astDollar = astS[astpt-1 : astpt+1]
//line ast.y:197
		{
			astVAL.node = AstNode{LexToken{0, 0, AstToplevel}, []AstNode{astDollar[1].node}}
		}
	case 73:
		astDollar = astS[astpt-2 : astpt+1]
//line ast.y:198
		{
			astDollar[1].node.nodes = append(astDollar[1].node.nodes, astDollar[2].node)
			astVAL.node = astDollar[1].node
		}
	case 74:
		astDollar = astS[astpt-1 : astpt+1]
//line ast.y:202
		{
			astlex.receiveResult(astDollar[1].node)
			return 0
		}
	}
	goto aststack /* stack new state and value */
}
